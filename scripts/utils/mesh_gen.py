# Modified from TacEx code
# https://github.com/DH-Ng/TacEx/blob/main/source/tacex_uipc/tacex_uipc/utils/mesh_gen.py
#
# import pymesh
# from meshpy.tet import MeshInfo, build, Options
# from isaacsim.util.debug_draw import _debug_draw
from omni.physx.scripts import deformableUtils
from pxr import Sdf, Usd, UsdGeom

# draw = _debug_draw.acquire_debug_draw_interface()

import numpy as np
import random

import wildmeshing as wm

from isaaclab.utils import configclass


@configclass
class TetMeshCfg:
    """

    References:

    """

    stop_quality: int = 10
    """
    Max AMIPS energy for stopping mesh optimization.

    Larger means less optimization and sooner stopping.
    """

    max_its: int = 80
    """
    Max number of mesh optimization iterations.
    """

    epsilon_r: float = 1e-2
    """ Relative envelope epsilon_r (definies the envelope size).

    -> Absolute epsilon = epsilon_r * diagonal_of_bbox.

    Smaller envelope preserves features better.
    Large Envelope + large edge_length = tetmesh with low res
    """

    edge_length_r: float = 1 / 2
    """ Relative target edge length l_r.

    -> Absolute l = l_r * diagonal_of_bbox.

    Smaller edge length gives denser mesh.
    """

    skip_simplify: bool = False

    coarsen: bool = True

    log_level: int = 6
    """
    Log level, ranges from 0 to 6  (0 = most verbose, 6 = off).
    """


@configclass
class TriMeshCfg:
    """

    References:

    """

    stop_quality: int = 10
    """
    Max AMIPS energy for stopping mesh optimization.

    Larger means less optimization and sooner stopping.
    """

    max_its: int = 80
    """
    Max number of mesh optimization iterations.
    """

    epsilon_r: float = 1e-2
    """ Relative envelope epsilon_r (definies the envelope size).
    -> Absolute epsilon = epsilon_r * diagonal_of_bbox.

    Smaller envelope pereserves features better.
    Larger Envelope + larger edge_length = tetmesh with low res
    """

    edge_length_r: float = 1 / 2
    """ Relative target edge length l_r.
    -> Absolute l = l_r * diagonal_of_bbox.

    Smaller edge length gives denser mesh.
    """

    skip_simplify: bool = False

    coarsen: bool = True

    log_level: int = 6
    """
    Log level, ranges from 0 to 6  (0 = most verbose, 6 = off).
    """


class MeshGenerator:
    def __init__(self, config: dict | TetMeshCfg = None) -> None:
        if config is None:
            config = TetMeshCfg().to_dict()
            print("No config for tet computation provided, using default settings.")
        elif type(config) is TetMeshCfg:
            config = config.to_dict()
        self.cfg = config

        # tetgen = pymesh.tetgen()
        # tetgen.points = mesh.vertices # Input points.
        # tetgen.triangles = mesh.faces # Input triangles

        # # set tetgen settings
        # for k, v in config.items():
        #     try:
        #         getattr(tetgen, k)
        #     except AttributeError:
        #         raise ValueError("invalid option for tet generation: %s" % k)
        #     else:
        #         if v is not None:
        #             setattr(tetgen, k, v)

        # tetgen.run() # Execute tetgen
        # mesh = tetgen.mesh # Extract output tetrahedral mesh.
        # print("tet mesh information ")
        # print(mesh.num_vertices, mesh.num_faces, mesh.num_voxels)
        # tet_points = mesh.vertices
        # tet_indices = mesh.voxels

        # use Wildmeshing
        # reference: https://github.com/wildmeshing/wildmeshing-python/blob/master/wildmeshing/runners.py
        self.tetrahedralizer = wm.Tetrahedralizer(
            stop_quality=self.cfg["stop_quality"],  # Specify max AMIPS energy for stopping mesh optimization"
            max_its=self.cfg["max_its"],  # Max number of mesh optimization iterations
            epsilon=self.cfg[
                "epsilon_r"
            ],  # relative envelope epsilon_r. Absolute epsilon = epsilon_r * diagonal_of_bbox
            edge_length_r=self.cfg[
                "edge_length_r"
            ],  # Relative target edge length l_r. Absolute l = l_r * diagonal_of_bbox
            skip_simplify=self.cfg["skip_simplify"],
            coarsen=self.cfg["coarsen"],
        )
        self.tetrahedralizer.set_log_level(
            self.cfg["log_level"]
        )  # Log level (0 = most verbose, 6 = off). 6 also means, that no tet data files are being generated by wildmeshing

    # def fix_mesh(self, mesh, detail="normal"):
    #     """
    #     Remesh the input mesh to remove degeneracies and improve triangle quality.

    #     Source: https://github.com/PyMesh/PyMesh/blob/main/scripts/fix_mesh.py
    #     Args:
    #         mesh (_type_): _description_
    #     """
    #     bbox_min, bbox_max = mesh.bbox
    #     diag_len = norm(bbox_max - bbox_min)
    #     print(f"diag_len = {diag_len}")
    #     if detail == "high":
    #         target_len = diag_len * 2.5e-3
    #     elif detail == "normal":
    #          target_len = diag_len * 5e-3 # adjusted values, cause we deal with very small objects, orig: 5e-3
    #     elif detail == "low":
    #         target_len = diag_len * 1e-2
    #     elif detail == "very low":
    #         target_len = diag_len * 5e-2

    #     print("Target resolution: {} mm".format(target_len))

    #     count = 0
    #     mesh, __ = pymesh.remove_duplicated_vertices(mesh, tol=target_len*1e-2)
    #     mesh, __ = pymesh.remove_degenerated_triangles(mesh, 100)
    #     #mesh, __ = pymesh.split_long_edges(mesh, target_len*2)
    #     num_vertices = mesh.num_vertices
    #     while True:
    #         mesh, __ = pymesh.collapse_short_edges(mesh, 1e-6, preserve_feature=True)
    #         mesh, __ = pymesh.collapse_short_edges(mesh, target_len,
    #                                                preserve_feature=True)
    #         mesh, __ = pymesh.remove_obtuse_triangles(mesh, 150.0, 100)
    #         if mesh.num_vertices == num_vertices:
    #             break

    #         num_vertices = mesh.num_vertices
    #         print(f"#v: {num_vertices}")
    #         count += 1
    #         if count > 10: break

    #     mesh = pymesh.resolve_self_intersection(mesh)
    #     mesh, __ = pymesh.remove_duplicated_faces(mesh)
    #     mesh = pymesh.compute_outer_hull(mesh)
    #     mesh, __ = pymesh.remove_duplicated_faces(mesh)
    #     mesh, __ = pymesh.remove_obtuse_triangles(mesh, 179.0, 5)
    #     mesh, __ = pymesh.remove_isolated_vertices(mesh)

    #     return mesh
    def generate_tet_mesh_for_prim(self, prim: UsdGeom.Mesh):
        # compute mesh
        points = np.array(prim.GetPointsAttr().Get())
        # triangles is a list of indices: every 3 consecutive indices form a triangle
        triangles = deformableUtils.triangulate_mesh(prim)

        tet_mesh_points, tet_indices, surf_points, surf_indices = self.compute_tet_mesh(points, triangles)

        # draw the tet mesh
        # color = [(0,0,0,1)]
        # for i in range(0, len(tet_indices), 4):
        #     tet_points_idx = tet_indices[i:i+4]
        #     tet_points = [tet_mesh_points[i] for i in tet_points_idx]
        #     #draw.draw_points(tet_points, [(255,0,0,1)]*len(all_vertices), [10]*len(all_vertices))
        #     draw.draw_lines([tet_points[0]]*3, tet_points[1:], color*3, [10]*3) # draw from point 0 to every other point (3 times 0, cause line from 0 to the other 3 points)
        #     draw.draw_lines([tet_points[1]]*2, tet_points[2:], color*2, [10]*2)
        #     draw.draw_lines([tet_points[2]], [tet_points[3]], color, [10]) # draw line between the other 2 points

        return tet_mesh_points, tet_indices, surf_points, surf_indices

    def compute_tet_mesh(self, points, triangles):
        triangles = np.array(triangles, dtype=np.uint32).reshape(-1, 3)
        points = np.array(points, dtype=np.float64)

        # use Pymesh
        # mesh = pymesh.form_mesh(points, triangles)
        # print("input tri mesh")
        # print(f"#vertices {mesh.num_vertices}, #faces {mesh.num_faces}")

        # # # clean up tri mesh
        # # # mesh, info = pymesh.remove_duplicated_vertices(mesh, tol=0.00005)
        # # # mesh, info = pymesh.collapse_short_edges(mesh,  rel_threshold=0.1,  preserve_feature=True)
        # # # mesh, info = pymesh.remove_isolated_vertices(mesh)
        # # # mesh, info = pymesh.remove_degenerated_triangles(mesh, num_iterations=5)

        # #mesh = self.fix_mesh(mesh, detail="very low") # doesn't work well, idk why... Maybe input mesh is not good enough
        # # print("tri mesh after cleanup: ")
        # # print(f"#vertices {mesh.num_vertices}, #faces {mesh.num_faces}")

        # # from omni.isaac.debug_draw import _debug_draw
        # # draw = _debug_draw.acquire_debug_draw_interface()
        # # for t in range(0, len(triangles.flatten().tolist()), 3):
        # #     tri_points = points[t:t+3]
        # #     draw.draw_lines([tri_points[0]]*2, tri_points[1:], [(255,255,255,0.5)]*2, [10]*2) # draw from point 0 to every other point (3 times 0, cause line from 0 to the other 3 points)
        # #     draw.draw_lines([tri_points[1]], [tri_points[2]], [(255,255,255,0.5)], [10])

        self.tetrahedralizer.set_mesh(points, triangles)
        self.tetrahedralizer.tetrahedralize()
        tet_points, tet_indices, _ = self.tetrahedralizer.get_tet_mesh(
            correct_surface_orientation=True,
            manifold_surface=True,
            use_input_for_wn=False,
        )
        tet_indices = np.array(tet_indices).flatten().tolist()

        # surface
        surf_points, surf_indices = self.tetrahedralizer.get_tracked_surfaces()
        surf_points = surf_points[0]  # surf_points is a list -> in case object consists of multiple surfaces
        surf_indices = np.array(surf_indices).flatten().tolist()
        return tet_points, tet_indices, surf_points, surf_indices

    @staticmethod
    def update_usd_mesh(prim: UsdGeom.Mesh, surf_points, triangles: list[int]):
        triangles = np.array(triangles).reshape(-1, 3)

        prim.GetPointsAttr().Set(surf_points)
        prim.GetFaceVertexCountsAttr().Set(
            [3] * triangles.shape[0]
        )  # how many vertices each face has (3, cause triangles)
        prim.GetFaceVertexIndicesAttr().Set(triangles)
        prim.GetNormalsAttr().Set([])  # set to be empty, cause we use catmullClark and this gives us normals
        prim.SetNormalsInterpolation(UsdGeom.Tokens.faceVarying)
        # prim.GetSubdivisionSchemeAttr().Set("catmullClark") #none

        # set color with per face interpolation
        colors = [
            (random.uniform(0.0, 0.0), random.uniform(0.0, 0.75), random.uniform(0.0, 0.75))
            for _ in range(triangles.shape[0] * 3)
        ]
        prim.CreateDisplayColorPrimvar(UsdGeom.Tokens.faceVarying).Set(colors)  # num_surf_tri * 3

        # texture map
        uv_coor = np.indices((int(triangles.size), 2)).transpose((1, 2, 0)).reshape((-1, 2))

        pv_api = UsdGeom.PrimvarsAPI(prim)
        if pv_api.HasPrimvar("primvars:st"):
            pv = pv_api.GetPrimvar("primvars:st")
            pv.SetInterpolation(UsdGeom.Tokens.faceVarying)
            # if uv_coor.size != pv.Get():
            #     print("primvars:st array has the wrong size - updating it")
            #     pv.Set(uv_coor)
        else:
            # set some values for the uv_coor variable, if no values exist
            pv = pv_api.CreatePrimvar(
                "primvars:st",
                Sdf.ValueTypeNames.TexCoord2fArray,
                UsdGeom.Tokens.faceVarying,
                # UsdGeom.Tokens.uniform,
                uv_coor.size,
            )
            pv.Set(uv_coor)

    @staticmethod
    def update_usd_mesh_with_uipc_surface(prim: Usd.Prim):
        """Method to update render mesh topology based on the surface of the mesh in UIPC.

        Used for workaround so that textures can be applied to the meshes.
        """
        from uipc.geometry import extract_surface, flip_inward_triangles, label_surface, label_triangle_orient, tetmesh

        tet_points = prim.GetAttribute("tet_points").Get()
        tet_points = np.array(tet_points)

        tet_indices = prim.GetAttribute("tet_indices").Get()
        tet_indices = np.array(tet_indices).reshape(-1, 4)

        # compute mesh
        mesh = tetmesh(tet_points.copy(), tet_indices.copy())
        # enable the contact by labeling the surface
        label_surface(mesh)
        label_triangle_orient(mesh)  # -> only needed when we want to export the mesh with uipc
        # flip the triangles inward for better rendering
        mesh = flip_inward_triangles(mesh)
        surf = extract_surface(mesh)

        surf_points = surf.positions().view().reshape(-1, 3)
        triangles = surf.triangles().topo().view().reshape(-1).tolist()

        # update usd attributes
        attr_tet_surf_points = prim.CreateAttribute("tet_surf_points", Sdf.ValueTypeNames.Vector3fArray)
        attr_tet_surf_points.Set(surf_points)

        attr_tet_surf_indices = prim.CreateAttribute("tet_surf_indices", Sdf.ValueTypeNames.UIntArray)
        attr_tet_surf_indices.Set(triangles)

        # update render mesh
        prim = UsdGeom.Mesh(prim)

        triangles = np.array(triangles).reshape(-1, 3)
        prim.GetPointsAttr().Set(surf_points)
        prim.GetFaceVertexCountsAttr().Set(
            [3] * triangles.shape[0]
        )  # how many vertices each face has (3, cause triangles)
        prim.GetFaceVertexIndicesAttr().Set(triangles)
        prim.GetNormalsAttr().Set([])  # set to be empty, cause we use catmullClark and this gives us normals
        prim.SetNormalsInterpolation(UsdGeom.Tokens.faceVarying)
        # prim.GetSubdivisionSchemeAttr().Set("catmullClark") #none

        # set color with per face interpolation
        colors = [
            (random.uniform(0.0, 0.0), random.uniform(0.0, 0.75), random.uniform(0.0, 0.75))
            for _ in range(triangles.shape[0] * 3)
        ]
        prim.CreateDisplayColorPrimvar(UsdGeom.Tokens.faceVarying).Set(colors)  # num_surf_tri * 3

        # set uv_coor variable
        uv_coor = np.indices((int(triangles.shape[0] * 1.5), 2)).transpose((1, 2, 0)).reshape((-1, 2))

        pv_api = UsdGeom.PrimvarsAPI(prim)
        if pv_api.HasPrimvar("primvars:st"):
            pv = pv_api.GetPrimvar("primvars:st")
            pv.SetInterpolation(UsdGeom.Tokens.faceVarying)
        else:
            pv = pv_api.CreatePrimvar(
                "primvars:st", Sdf.ValueTypeNames.TexCoord2fArray, UsdGeom.Tokens.faceVarying, uv_coor.size
            )
        pv.Set(uv_coor)
